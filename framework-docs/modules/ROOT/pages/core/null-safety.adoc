[[null-safety]]
= Null-safety

Although Java does not let you express null-safety with its type system, the Spring Framework
codebase is annotated with https://jspecify.dev/docs/start-here/[JSpecify] annotations (`org.jspecify.annotations`
package) to declare the nullability of APIs, fields and related type usages. Reading the
https://jspecify.dev/docs/user-guide/[JSpecify user guide] is highly recommended in order to get familiar with those
annotations and semantics.

The primary goal of this explicit null-safety arrangement is to prevent `NullPointerException` to be thrown at runtime via
build time checks and to turn explicit nullability into a way to express the possible absence of value. It is useful in
both Java by leveraging some tooling (https://github.com/uber/NullAway[NullAway] or IDEs supporting null-safety
annotations such as IntelliJ IDEA or Eclipse) and Kotlin where JSpecify annotations are automatically translated to
{kotlin-docs}/null-safety.html[nullability of Kotlin types], see xref:languages/kotlin/null-safety.adoc[related documentation].

`@Nullable` annotations are also used at runtime to infer if a parameter is optional or not, for example via
{spring-framework-api}/core/MethodParameter.html#isOptional()[`MethodParameter#isOptional`].

[[null-safety-libraries]]
== Annotating libraries with JSpecify annotations

As of Spring Framework 7, the Spring Framework codebase leverages JSpecify annotations to expose null-safe APIs and
check the consistency of those null-safety declarations with https://github.com/uber/NullAway[NullAway] as part of its
build. It is recommended for each library depending on Spring Framework (Spring portfolio projects), as
well as other libraries related to the Spring ecosystem (Reactor, Micrometer and Spring community projects), to do the
same.

[[null-safety-applications]]
== Leveraging JSpecify annotations in Spring applications

Developing applications with IDEs supporting null-safety annotations such as IntelliJ IDEA or Eclipse will provide
warnings in Java and errors in Kotlin when the null-safety contracts are not honored, allowing Spring application
developers to refine their null handling to prevent `NullPointerException` to be thrown at runtime.

Optionally, Spring application developers can annotate their codebase and use https://github.com/uber/NullAway[NullAway]
to enforce null-safety during build time at application level.

[[null-safety-guidelines]]
== Guidelines

The purpose of this section is to share some guidelines proposed for using JSpecify annotations in the context of
Spring-related libraries or applications.

The first key points to understand is that by default the nullability of types is unknown in Java, and that non-null type
usages are by far more request than nullable ones. So in order to keep our codebase readable, we want to define
for a specific scope that by default, type usages are non-null unless marked as nullable. This is exactly the purpose of
https://jspecify.dev/docs/api/org/jspecify/annotations/NullMarked.html[`@NullMarked`] that is typically set with Spring
at package level via a `package-info.java` file, for example:

[source,java,subs="verbatim,quotes",chomp="-packages",fold="none"]
----
@NullMarked
package org.springframework.core;

import org.jspecify.annotations.NullMarked;
----

In the various Java files belonging to the package, nullable type usages are defined explicitly with
https://jspecify.dev/docs/api/org/jspecify/annotations/Nullable.html[`@Nullable`]. It is recommended that this
annotation is specified just before the related type.

For example, for a field:

[source,java,subs="verbatim,quotes"]
----
private @Nullable String fileEncoding;
----

Or for a method parameter and return value:

[source,java,subs="verbatim,quotes"]
----
public static @Nullable String buildMessage(@Nullable String message, @Nullable Throwable cause) {
    // ...
}
----

When overriding a method, nullability annotations are not inherited from the superclass method. That means those
nullability annotations should be repeated if you just want to override the implementation and keep the same API
nullability.

With arrays and varargs, you need to be able to differentiate the nullability of the elements from the nullability of
the array itself. Pay attention to the syntax
https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4[defined by the Java specification] which may be
initially surprising:

- `@Nullable Object[] array` means individual elements can be null but the array itself can't.
- `Object @Nullable [] array` means individual elements can't be null but the array itself can.
- `@Nullable Object @Nullable [] array` means both individual elements and the array can be null.

The Java specifications also enforces that annotations defined with `@Target(ElementType.TYPE_USE)` should be specified
after the last `.` with fully qualified or inner types:

 - `Cache.@Nullable ValueWrapper`
 - `jakarta.validation.@Nullable Validator`

https://jspecify.dev/docs/api/org/jspecify/annotations/NonNull.html[`@NonNull`] and
https://jspecify.dev/docs/api/org/jspecify/annotations/NullUnmarked.html[`@NullUnmarked`] should rarely be needed for
typical use cases.

The {spring-framework-api}/lang/Contract.html[@Contract] annotation in the `org.springframework.lang` package
can be used to express complementary semantics to avoid non-relevant null-safety warnings in your codebase.

[[null-safety-migrating]]
== Migrating from Spring null-safety annotations

Spring null-safety annotations {spring-framework-api}/lang/Nullable.html[`@Nullable`],
{spring-framework-api}/lang/NonNull.html[`@NonNull`],
{spring-framework-api}/lang/NonNullApi.html[`@NonNullApi`], and
{spring-framework-api}/lang/NonNullFields.html[`@NonNullFields`] provided in the
`org.springframework.lang` package are deprecated as of Spring Framework 7 and superseded
by JSpecify annotations.

A key difference is that Spring null-safety annotations, following JSR 305 semantics, apply to fields,
parameters and return values while JSpecify annotations apply to type usages. This subtle difference
is in practice pretty significant, as it allows for example to differentiate the nullability of elements from the
nullability of arrays/varargs as well as the nullability of generic types.

That means array and varargs null-safety declarations have to be updated to keep the same semantic. For example
`@org.springframework.lang.Nullable Object[] array` needs to be changed to
`Object @org.jspecify.annotations.Nullable [] array`. Same for varargs.

It is also recommended to move field and return value annotation closer to the type, for example:

 - For fields, use `private @Nullable String field` instead of `@Nullable private String field`
 - For return values, use `public @Nullable String method()` instead of `@Nullable public String method()`

With JSpecify, you don't need to specify `@NonNull` when overriding a type usage annotated with `@Nullable` in the super
method to "undo" the nullable declaration in null-marked code.

